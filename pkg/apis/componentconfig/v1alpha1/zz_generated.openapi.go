// +build !ignore_autogenerated

/*
Copyright 2016 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This file was autogenerated by openapi-gen. Do not edit it manually!

package v1alpha1

import (
	spec "github.com/go-openapi/spec"
	unversioned "k8s.io/kubernetes/pkg/api/unversioned"
	openapi "k8s.io/kubernetes/pkg/genericapiserver/openapi"
)

func (_ KubeProxyConfiguration) OpenAPI() openapi.OpenAPIType {
	schema := spec.Schema{}
	schema.Description = ""
	schema.Properties = map[string]spec.Schema{
		"TypeMeta": {
			SchemaProps: spec.SchemaProps{
				Ref: spec.MustCreateRef("#/definitions/unversioned.TypeMeta"),
			},
		},
		"bindAddress": {
			SchemaProps: spec.SchemaProps{
				Description: "bindAddress is the IP address for the proxy server to serve on (set to 0.0.0.0 for all interfaces)",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"clusterCIDR": {
			SchemaProps: spec.SchemaProps{
				Description: "clusterCIDR is the CIDR range of the pods in the cluster. It is used to bridge traffic coming from outside of the cluster. If not provided, no off-cluster bridging will be performed.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"healthzBindAddress": {
			SchemaProps: spec.SchemaProps{
				Description: "healthzBindAddress is the IP address for the health check server to serve on, defaulting to 127.0.0.1 (set to 0.0.0.0 for all interfaces)",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"healthzPort": {
			SchemaProps: spec.SchemaProps{
				Description: "healthzPort is the port to bind the health check server. Use 0 to disable.",
				Type:        []string{"integer"},
				Format:      "int32",
			},
		},
		"hostnameOverride": {
			SchemaProps: spec.SchemaProps{
				Description: "hostnameOverride, if non-empty, will be used as the identity instead of the actual hostname.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"iptablesMasqueradeBit": {
			SchemaProps: spec.SchemaProps{
				Description: "iptablesMasqueradeBit is the bit of the iptables fwmark space to use for SNAT if using the pure iptables proxy mode. Values must be within the range [0, 31].",
				Type:        []string{"integer"},
				Format:      "int32",
			},
		},
		"iptablesSyncPeriodSeconds": {
			SchemaProps: spec.SchemaProps{
				Ref: spec.MustCreateRef("#/definitions/unversioned.Duration"),
			},
		},
		"kubeconfigPath": {
			SchemaProps: spec.SchemaProps{
				Description: "kubeconfigPath is the path to the kubeconfig file with authorization information (the master location is set by the master flag).",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"masqueradeAll": {
			SchemaProps: spec.SchemaProps{
				Description: "masqueradeAll tells kube-proxy to SNAT everything if using the pure iptables proxy mode.",
				Type:        []string{"boolean"},
				Format:      "",
			},
		},
		"master": {
			SchemaProps: spec.SchemaProps{
				Description: "master is the address of the Kubernetes API server (overrides any value in kubeconfig)",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"oomScoreAdj": {
			SchemaProps: spec.SchemaProps{
				Description: "oomScoreAdj is the oom-score-adj value for kube-proxy process. Values must be within the range [-1000, 1000]",
				Type:        []string{"integer"},
				Format:      "int32",
			},
		},
		"mode": {
			SchemaProps: spec.SchemaProps{
				Description: "mode specifies which proxy mode to use.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"portRange": {
			SchemaProps: spec.SchemaProps{
				Description: "portRange is the range of host ports (beginPort-endPort, inclusive) that may be consumed in order to proxy service traffic. If unspecified (0-0) then ports will be randomly chosen.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"resourceContainer": {
			SchemaProps: spec.SchemaProps{
				Description: "resourceContainer is the bsolute name of the resource-only container to create and run the Kube-proxy in (Default: /kube-proxy).",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"udpTimeoutMilliseconds": {
			SchemaProps: spec.SchemaProps{
				Ref: spec.MustCreateRef("#/definitions/unversioned.Duration"),
			},
		},
		"conntrackMax": {
			SchemaProps: spec.SchemaProps{
				Description: "conntrackMax is the maximum number of NAT connections to track (0 to leave as-is).  This takes precendence over conntrackMaxPerCore.",
				Type:        []string{"integer"},
				Format:      "int32",
			},
		},
		"conntrackMaxPerCore": {
			SchemaProps: spec.SchemaProps{
				Description: "conntrackMaxPerCore is the maximum number of NAT connections to track per CPU core (0 to leave as-is).  This value is only considered if conntrackMax == 0.",
				Type:        []string{"integer"},
				Format:      "int32",
			},
		},
		"conntrackTCPEstablishedTimeout": {
			SchemaProps: spec.SchemaProps{
				Ref: spec.MustCreateRef("#/definitions/unversioned.Duration"),
			},
		},
	}
	schema.Required = []string{"TypeMeta", "bindAddress", "clusterCIDR", "healthzBindAddress", "healthzPort", "hostnameOverride", "iptablesMasqueradeBit", "iptablesSyncPeriodSeconds", "kubeconfigPath", "masqueradeAll", "master", "oomScoreAdj", "mode", "portRange", "resourceContainer", "udpTimeoutMilliseconds", "conntrackMax", "conntrackMaxPerCore", "conntrackTCPEstablishedTimeout"}
	return openapi.OpenAPIType{
		Schema: &schema,
		Dependencies: map[string]interface{}{
			"unversioned.Duration": unversioned.Duration{},
			"unversioned.TypeMeta": unversioned.TypeMeta{},
		},
	}
}

func (_ KubeSchedulerConfiguration) OpenAPI() openapi.OpenAPIType {
	schema := spec.Schema{}
	schema.Description = ""
	schema.Properties = map[string]spec.Schema{
		"TypeMeta": {
			SchemaProps: spec.SchemaProps{
				Ref: spec.MustCreateRef("#/definitions/unversioned.TypeMeta"),
			},
		},
		"port": {
			SchemaProps: spec.SchemaProps{
				Description: "port is the port that the scheduler's http service runs on.",
				Type:        []string{"integer"},
				Format:      "int32",
			},
		},
		"address": {
			SchemaProps: spec.SchemaProps{
				Description: "address is the IP address to serve on.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"algorithmProvider": {
			SchemaProps: spec.SchemaProps{
				Description: "algorithmProvider is the scheduling algorithm provider to use.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"policyConfigFile": {
			SchemaProps: spec.SchemaProps{
				Description: "policyConfigFile is the filepath to the scheduler policy configuration.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"enableProfiling": {
			SchemaProps: spec.SchemaProps{
				Description: "enableProfiling enables profiling via web interface.",
				Type:        []string{"boolean"},
				Format:      "",
			},
		},
		"contentType": {
			SchemaProps: spec.SchemaProps{
				Description: "contentType is contentType of requests sent to apiserver.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"kubeAPIQPS": {
			SchemaProps: spec.SchemaProps{
				Description: "kubeAPIQPS is the QPS to use while talking with kubernetes apiserver.",
				Type:        []string{"number"},
				Format:      "float",
			},
		},
		"kubeAPIBurst": {
			SchemaProps: spec.SchemaProps{
				Description: "kubeAPIBurst is the QPS burst to use while talking with kubernetes apiserver.",
				Type:        []string{"integer"},
				Format:      "int32",
			},
		},
		"schedulerName": {
			SchemaProps: spec.SchemaProps{
				Description: "schedulerName is name of the scheduler, used to select which pods will be processed by this scheduler, based on pod's annotation with key 'scheduler.alpha.kubernetes.io/name'.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"hardPodAffinitySymmetricWeight": {
			SchemaProps: spec.SchemaProps{
				Description: "RequiredDuringScheduling affinity is not symmetric, but there is an implicit PreferredDuringScheduling affinity rule corresponding to every RequiredDuringScheduling affinity rule. HardPodAffinitySymmetricWeight represents the weight of implicit PreferredDuringScheduling affinity rule, in the range 0-100.",
				Type:        []string{"integer"},
				Format:      "int32",
			},
		},
		"failureDomains": {
			SchemaProps: spec.SchemaProps{
				Description: "Indicate the \"all topologies\" set for empty topologyKey when it's used for PreferredDuringScheduling pod anti-affinity.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"leaderElection": {
			SchemaProps: spec.SchemaProps{
				Ref: spec.MustCreateRef("#/definitions/v1alpha1.LeaderElectionConfiguration"),
			},
		},
	}
	schema.Required = []string{"TypeMeta", "port", "address", "algorithmProvider", "policyConfigFile", "enableProfiling", "contentType", "kubeAPIQPS", "kubeAPIBurst", "schedulerName", "hardPodAffinitySymmetricWeight", "failureDomains", "leaderElection"}
	return openapi.OpenAPIType{
		Schema: &schema,
		Dependencies: map[string]interface{}{
			"unversioned.TypeMeta":                 unversioned.TypeMeta{},
			"v1alpha1.LeaderElectionConfiguration": LeaderElectionConfiguration{},
		},
	}
}

func (_ KubeletConfiguration) OpenAPI() openapi.OpenAPIType {
	schema := spec.Schema{}
	schema.Description = ""
	schema.Properties = map[string]spec.Schema{
		"TypeMeta": {
			SchemaProps: spec.SchemaProps{
				Ref: spec.MustCreateRef("#/definitions/unversioned.TypeMeta"),
			},
		},
		"podManifestPath": {
			SchemaProps: spec.SchemaProps{
				Description: "podManifestPath is the path to the directory containing pod manifests to run, or the path to a single manifest file",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"syncFrequency": {
			SchemaProps: spec.SchemaProps{
				Ref: spec.MustCreateRef("#/definitions/unversioned.Duration"),
			},
		},
		"fileCheckFrequency": {
			SchemaProps: spec.SchemaProps{
				Ref: spec.MustCreateRef("#/definitions/unversioned.Duration"),
			},
		},
		"httpCheckFrequency": {
			SchemaProps: spec.SchemaProps{
				Ref: spec.MustCreateRef("#/definitions/unversioned.Duration"),
			},
		},
		"manifestURL": {
			SchemaProps: spec.SchemaProps{
				Description: "manifestURL is the URL for accessing the container manifest",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"manifestURLHeader": {
			SchemaProps: spec.SchemaProps{
				Description: "manifestURLHeader is the HTTP header to use when accessing the manifest URL, with the key separated from the value with a ':', as in 'key:value'",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"enableServer": {
			SchemaProps: spec.SchemaProps{
				Description: "enableServer enables the Kubelet's server",
				Type:        []string{"boolean"},
				Format:      "",
			},
		},
		"address": {
			SchemaProps: spec.SchemaProps{
				Description: "address is the IP address for the Kubelet to serve on (set to 0.0.0.0 for all interfaces)",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"port": {
			SchemaProps: spec.SchemaProps{
				Description: "port is the port for the Kubelet to serve on.",
				Type:        []string{"integer"},
				Format:      "int32",
			},
		},
		"readOnlyPort": {
			SchemaProps: spec.SchemaProps{
				Description: "readOnlyPort is the read-only port for the Kubelet to serve on with no authentication/authorization (set to 0 to disable)",
				Type:        []string{"integer"},
				Format:      "int32",
			},
		},
		"tlsCertFile": {
			SchemaProps: spec.SchemaProps{
				Description: "tlsCertFile is the file containing x509 Certificate for HTTPS.  (CA cert, if any, concatenated after server cert). If tlsCertFile and tlsPrivateKeyFile are not provided, a self-signed certificate and key are generated for the public address and saved to the directory passed to certDir.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"tlsPrivateKeyFile": {
			SchemaProps: spec.SchemaProps{
				Description: "tlsPrivateKeyFile is the ile containing x509 private key matching tlsCertFile.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"certDirectory": {
			SchemaProps: spec.SchemaProps{
				Description: "certDirectory is the directory where the TLS certs are located (by default /var/run/kubernetes). If tlsCertFile and tlsPrivateKeyFile are provided, this flag will be ignored.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"hostnameOverride": {
			SchemaProps: spec.SchemaProps{
				Description: "hostnameOverride is the hostname used to identify the kubelet instead of the actual hostname.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"podInfraContainerImage": {
			SchemaProps: spec.SchemaProps{
				Description: "podInfraContainerImage is the image whose network/ipc namespaces containers in each pod will use.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"dockerEndpoint": {
			SchemaProps: spec.SchemaProps{
				Description: "dockerEndpoint is the path to the docker endpoint to communicate with.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"rootDirectory": {
			SchemaProps: spec.SchemaProps{
				Description: "rootDirectory is the directory path to place kubelet files (volume mounts,etc).",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"seccompProfileRoot": {
			SchemaProps: spec.SchemaProps{
				Description: "seccompProfileRoot is the directory path for seccomp profiles.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"allowPrivileged": {
			SchemaProps: spec.SchemaProps{
				Description: "allowPrivileged enables containers to request privileged mode. Defaults to false.",
				Type:        []string{"boolean"},
				Format:      "",
			},
		},
		"hostNetworkSources": {
			SchemaProps: spec.SchemaProps{
				Description: "hostNetworkSources is a comma-separated list of sources from which the Kubelet allows pods to use of host network. Defaults to \"*\". Valid options are \"file\", \"http\", \"api\", and \"*\" (all sources).",
				Type:        []string{"array"},
				Items: &spec.SchemaOrArray{
					Schema: &spec.Schema{
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
				},
			},
		},
		"hostPIDSources": {
			SchemaProps: spec.SchemaProps{
				Description: "hostPIDSources is a comma-separated list of sources from which the Kubelet allows pods to use the host pid namespace. Defaults to \"*\".",
				Type:        []string{"array"},
				Items: &spec.SchemaOrArray{
					Schema: &spec.Schema{
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
				},
			},
		},
		"hostIPCSources": {
			SchemaProps: spec.SchemaProps{
				Description: "hostIPCSources is a comma-separated list of sources from which the Kubelet allows pods to use the host ipc namespace. Defaults to \"*\".",
				Type:        []string{"array"},
				Items: &spec.SchemaOrArray{
					Schema: &spec.Schema{
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
				},
			},
		},
		"registryPullQPS": {
			SchemaProps: spec.SchemaProps{
				Description: "registryPullQPS is the limit of registry pulls per second. If 0, unlimited. Set to 0 for no limit. Defaults to 5.0.",
				Type:        []string{"integer"},
				Format:      "int32",
			},
		},
		"registryBurst": {
			SchemaProps: spec.SchemaProps{
				Description: "registryBurst is the maximum size of a bursty pulls, temporarily allows pulls to burst to this number, while still not exceeding registryQps. Only used if registryQPS > 0.",
				Type:        []string{"integer"},
				Format:      "int32",
			},
		},
		"eventRecordQPS": {
			SchemaProps: spec.SchemaProps{
				Description: "eventRecordQPS is the maximum event creations per second. If 0, there is no limit enforced.",
				Type:        []string{"integer"},
				Format:      "int32",
			},
		},
		"eventBurst": {
			SchemaProps: spec.SchemaProps{
				Description: "eventBurst is the maximum size of a bursty event records, temporarily allows event records to burst to this number, while still not exceeding event-qps. Only used if eventQps > 0",
				Type:        []string{"integer"},
				Format:      "int32",
			},
		},
		"enableDebuggingHandlers": {
			SchemaProps: spec.SchemaProps{
				Description: "enableDebuggingHandlers enables server endpoints for log collection and local running of containers and commands",
				Type:        []string{"boolean"},
				Format:      "",
			},
		},
		"minimumGCAge": {
			SchemaProps: spec.SchemaProps{
				Ref: spec.MustCreateRef("#/definitions/unversioned.Duration"),
			},
		},
		"maxPerPodContainerCount": {
			SchemaProps: spec.SchemaProps{
				Description: "maxPerPodContainerCount is the maximum number of old instances to retain per container. Each container takes up some disk space.",
				Type:        []string{"integer"},
				Format:      "int32",
			},
		},
		"maxContainerCount": {
			SchemaProps: spec.SchemaProps{
				Description: "maxContainerCount is the maximum number of old instances of containers to retain globally. Each container takes up some disk space.",
				Type:        []string{"integer"},
				Format:      "int32",
			},
		},
		"cAdvisorPort": {
			SchemaProps: spec.SchemaProps{
				Description: "cAdvisorPort is the port of the localhost cAdvisor endpoint",
				Type:        []string{"integer"},
				Format:      "int32",
			},
		},
		"healthzPort": {
			SchemaProps: spec.SchemaProps{
				Description: "healthzPort is the port of the localhost healthz endpoint",
				Type:        []string{"integer"},
				Format:      "int32",
			},
		},
		"healthzBindAddress": {
			SchemaProps: spec.SchemaProps{
				Description: "healthzBindAddress is the IP address for the healthz server to serve on.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"oomScoreAdj": {
			SchemaProps: spec.SchemaProps{
				Description: "oomScoreAdj is The oom-score-adj value for kubelet process. Values must be within the range [-1000, 1000].",
				Type:        []string{"integer"},
				Format:      "int32",
			},
		},
		"registerNode": {
			SchemaProps: spec.SchemaProps{
				Description: "registerNode enables automatic registration with the apiserver.",
				Type:        []string{"boolean"},
				Format:      "",
			},
		},
		"clusterDomain": {
			SchemaProps: spec.SchemaProps{
				Description: "clusterDomain is the DNS domain for this cluster. If set, kubelet will configure all containers to search this domain in addition to the host's search domains.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"masterServiceNamespace": {
			SchemaProps: spec.SchemaProps{
				Description: "masterServiceNamespace is The namespace from which the kubernetes master services should be injected into pods.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"clusterDNS": {
			SchemaProps: spec.SchemaProps{
				Description: "clusterDNS is the IP address for a cluster DNS server.  If set, kubelet will configure all containers to use this for DNS resolution in addition to the host's DNS servers",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"streamingConnectionIdleTimeout": {
			SchemaProps: spec.SchemaProps{
				Ref: spec.MustCreateRef("#/definitions/unversioned.Duration"),
			},
		},
		"nodeStatusUpdateFrequency": {
			SchemaProps: spec.SchemaProps{
				Ref: spec.MustCreateRef("#/definitions/unversioned.Duration"),
			},
		},
		"imageMinimumGCAge": {
			SchemaProps: spec.SchemaProps{
				Ref: spec.MustCreateRef("#/definitions/unversioned.Duration"),
			},
		},
		"imageGCHighThresholdPercent": {
			SchemaProps: spec.SchemaProps{
				Description: "imageGCHighThresholdPercent is the percent of disk usage after which image garbage collection is always run. The percent is calculated as this field value out of 100.",
				Type:        []string{"integer"},
				Format:      "int32",
			},
		},
		"imageGCLowThresholdPercent": {
			SchemaProps: spec.SchemaProps{
				Description: "imageGCLowThresholdPercent is the percent of disk usage before which image garbage collection is never run. Lowest disk usage to garbage collect to. The percent is calculated as this field value out of 100.",
				Type:        []string{"integer"},
				Format:      "int32",
			},
		},
		"lowDiskSpaceThresholdMB": {
			SchemaProps: spec.SchemaProps{
				Description: "lowDiskSpaceThresholdMB is the absolute free disk space, in MB, to maintain. When disk space falls below this threshold, new pods would be rejected.",
				Type:        []string{"integer"},
				Format:      "int32",
			},
		},
		"volumeStatsAggPeriod": {
			SchemaProps: spec.SchemaProps{
				Ref: spec.MustCreateRef("#/definitions/unversioned.Duration"),
			},
		},
		"networkPluginName": {
			SchemaProps: spec.SchemaProps{
				Description: "networkPluginName is the name of the network plugin to be invoked for various events in kubelet/pod lifecycle",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"networkPluginDir": {
			SchemaProps: spec.SchemaProps{
				Description: "networkPluginDir is the full path of the directory in which to search for network plugins",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"networkPluginMTU": {
			SchemaProps: spec.SchemaProps{
				Description: "networkPluginMTU is the MTU to be passed to the network plugin, and overrides the default MTU for cases where it cannot be automatically computed (such as IPSEC).",
				Type:        []string{"integer"},
				Format:      "int32",
			},
		},
		"volumePluginDir": {
			SchemaProps: spec.SchemaProps{
				Description: "volumePluginDir is the full path of the directory in which to search for additional third party volume plugins",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"cloudProvider": {
			SchemaProps: spec.SchemaProps{
				Description: "cloudProvider is the provider for cloud services.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"cloudConfigFile": {
			SchemaProps: spec.SchemaProps{
				Description: "cloudConfigFile is the path to the cloud provider configuration file.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"kubeletCgroups": {
			SchemaProps: spec.SchemaProps{
				Description: "kubeletCgroups is the absolute name of cgroups to isolate the kubelet in.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"runtimeCgroups": {
			SchemaProps: spec.SchemaProps{
				Description: "runtimeCgroups are cgroups that container runtime is expected to be isolated in.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"systemCgroups": {
			SchemaProps: spec.SchemaProps{
				Description: "systemCgroups is absolute name of cgroups in which to place all non-kernel processes that are not already in a container. Empty for no container. Rolling back the flag requires a reboot.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"cgroupRoot": {
			SchemaProps: spec.SchemaProps{
				Description: "cgroupRoot is the root cgroup to use for pods. This is handled by the container runtime on a best effort basis.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"CgroupsPerQOS": {
			SchemaProps: spec.SchemaProps{
				Description: "Enable QoS based Cgroup hierarchy: top level cgroups for QoS Classes And all Burstable and BestEffort pods are brought up under their specific top level QoS cgroup.",
				Type:        []string{"boolean"},
				Format:      "",
			},
		},
		"containerRuntime": {
			SchemaProps: spec.SchemaProps{
				Description: "containerRuntime is the container runtime to use.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"remoteRuntimeEndpoint": {
			SchemaProps: spec.SchemaProps{
				Description: "remoteRuntimeEndpoint is the endpoint of remote runtime service",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"remoteImageEndpoint": {
			SchemaProps: spec.SchemaProps{
				Description: "remoteImageEndpoint is the endpoint of remote image service",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"runtimeRequestTimeout": {
			SchemaProps: spec.SchemaProps{
				Ref: spec.MustCreateRef("#/definitions/unversioned.Duration"),
			},
		},
		"rktPath": {
			SchemaProps: spec.SchemaProps{
				Description: "rktPath is the  path of rkt binary. Leave empty to use the first rkt in $PATH.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"rktAPIEndpoint": {
			SchemaProps: spec.SchemaProps{
				Description: "rktApiEndpoint is the endpoint of the rkt API service to communicate with.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"rktStage1Image": {
			SchemaProps: spec.SchemaProps{
				Description: "rktStage1Image is the image to use as stage1. Local paths and http/https URLs are supported.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"lockFilePath": {
			SchemaProps: spec.SchemaProps{
				Description: "lockFilePath is the path that kubelet will use to as a lock file. It uses this file as a lock to synchronize with other kubelet processes that may be running.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"exitOnLockContention": {
			SchemaProps: spec.SchemaProps{
				Description: "ExitOnLockContention is a flag that signifies to the kubelet that it is running in \"bootstrap\" mode. This requires that 'LockFilePath' has been set. This will cause the kubelet to listen to inotify events on the lock file, releasing it and exiting when another process tries to open that file.",
				Type:        []string{"boolean"},
				Format:      "",
			},
		},
		"configureCbr0": {
			SchemaProps: spec.SchemaProps{
				Description: "configureCBR0 enables the kublet to configure cbr0 based on Node.Spec.PodCIDR.",
				Type:        []string{"boolean"},
				Format:      "",
			},
		},
		"hairpinMode": {
			SchemaProps: spec.SchemaProps{
				Description: "How should the kubelet configure the container bridge for hairpin packets. Setting this flag allows endpoints in a Service to loadbalance back to themselves if they should try to access their own Service. Values:\n  \"promiscuous-bridge\": make the container bridge promiscuous.\n  \"hairpin-veth\":       set the hairpin flag on container veth interfaces.\n  \"none\":               do nothing.\nSetting --configure-cbr0 to false implies that to achieve hairpin NAT one must set --hairpin-mode=veth-flag, because bridge assumes the existence of a container bridge named cbr0.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"babysitDaemons": {
			SchemaProps: spec.SchemaProps{
				Description: "The node has babysitter process monitoring docker and kubelet.",
				Type:        []string{"boolean"},
				Format:      "",
			},
		},
		"maxPods": {
			SchemaProps: spec.SchemaProps{
				Description: "maxPods is the number of pods that can run on this Kubelet.",
				Type:        []string{"integer"},
				Format:      "int32",
			},
		},
		"nvidiaGPUs": {
			SchemaProps: spec.SchemaProps{
				Description: "nvidiaGPUs is the number of NVIDIA GPU devices on this node.",
				Type:        []string{"integer"},
				Format:      "int32",
			},
		},
		"dockerExecHandlerName": {
			SchemaProps: spec.SchemaProps{
				Description: "dockerExecHandlerName is the handler to use when executing a command in a container. Valid values are 'native' and 'nsenter'. Defaults to 'native'.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"podCIDR": {
			SchemaProps: spec.SchemaProps{
				Description: "The CIDR to use for pod IP addresses, only used in standalone mode. In cluster mode, this is obtained from the master.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"resolvConf": {
			SchemaProps: spec.SchemaProps{
				Description: "ResolverConfig is the resolver configuration file used as the basis for the container DNS resolution configuration.\"), []",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"cpuCFSQuota": {
			SchemaProps: spec.SchemaProps{
				Description: "cpuCFSQuota is Enable CPU CFS quota enforcement for containers that specify CPU limits",
				Type:        []string{"boolean"},
				Format:      "",
			},
		},
		"containerized": {
			SchemaProps: spec.SchemaProps{
				Description: "containerized should be set to true if kubelet is running in a container.",
				Type:        []string{"boolean"},
				Format:      "",
			},
		},
		"maxOpenFiles": {
			SchemaProps: spec.SchemaProps{
				Description: "maxOpenFiles is Number of files that can be opened by Kubelet process.",
				Type:        []string{"integer"},
				Format:      "int64",
			},
		},
		"reconcileCIDR": {
			SchemaProps: spec.SchemaProps{
				Description: "reconcileCIDR is Reconcile node CIDR with the CIDR specified by the API server. No-op if register-node or configure-cbr0 is false.",
				Type:        []string{"boolean"},
				Format:      "",
			},
		},
		"registerSchedulable": {
			SchemaProps: spec.SchemaProps{
				Description: "registerSchedulable tells the kubelet to register the node as schedulable. No-op if register-node is false.",
				Type:        []string{"boolean"},
				Format:      "",
			},
		},
		"contentType": {
			SchemaProps: spec.SchemaProps{
				Description: "contentType is contentType of requests sent to apiserver.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"kubeAPIQPS": {
			SchemaProps: spec.SchemaProps{
				Description: "kubeAPIQPS is the QPS to use while talking with kubernetes apiserver",
				Type:        []string{"integer"},
				Format:      "int32",
			},
		},
		"kubeAPIBurst": {
			SchemaProps: spec.SchemaProps{
				Description: "kubeAPIBurst is the burst to allow while talking with kubernetes apiserver",
				Type:        []string{"integer"},
				Format:      "int32",
			},
		},
		"serializeImagePulls": {
			SchemaProps: spec.SchemaProps{
				Description: "serializeImagePulls when enabled, tells the Kubelet to pull images one at a time. We recommend *not* changing the default value on nodes that run docker daemon with version  < 1.9 or an Aufs storage backend. Issue #10959 has more details.",
				Type:        []string{"boolean"},
				Format:      "",
			},
		},
		"experimentalFlannelOverlay": {
			SchemaProps: spec.SchemaProps{
				Description: "experimentalFlannelOverlay enables experimental support for starting the kubelet with the default overlay network (flannel). Assumes flanneld is already running in client mode.",
				Type:        []string{"boolean"},
				Format:      "",
			},
		},
		"outOfDiskTransitionFrequency": {
			SchemaProps: spec.SchemaProps{
				Ref: spec.MustCreateRef("#/definitions/unversioned.Duration"),
			},
		},
		"nodeIP": {
			SchemaProps: spec.SchemaProps{
				Description: "nodeIP is IP address of the node. If set, kubelet will use this IP address for the node.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"nodeLabels": {
			SchemaProps: spec.SchemaProps{
				Description: "nodeLabels to add when registering the node in the cluster.",
				Type:        []string{"object"},
				AdditionalProperties: &spec.SchemaOrBool{
					Schema: &spec.Schema{
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
				},
			},
		},
		"nonMasqueradeCIDR": {
			SchemaProps: spec.SchemaProps{
				Description: "nonMasqueradeCIDR configures masquerading: traffic to IPs outside this range will use IP masquerade.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"enableCustomMetrics": {
			SchemaProps: spec.SchemaProps{
				Description: "enable gathering custom metrics.",
				Type:        []string{"boolean"},
				Format:      "",
			},
		},
		"evictionHard": {
			SchemaProps: spec.SchemaProps{
				Description: "Comma-delimited list of hard eviction expressions.  For example, 'memory.available<300Mi'.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"evictionSoft": {
			SchemaProps: spec.SchemaProps{
				Description: "Comma-delimited list of soft eviction expressions.  For example, 'memory.available<300Mi'.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"evictionSoftGracePeriod": {
			SchemaProps: spec.SchemaProps{
				Description: "Comma-delimeted list of grace periods for each soft eviction signal.  For example, 'memory.available=30s'.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"evictionPressureTransitionPeriod": {
			SchemaProps: spec.SchemaProps{
				Ref: spec.MustCreateRef("#/definitions/unversioned.Duration"),
			},
		},
		"evictionMaxPodGracePeriod": {
			SchemaProps: spec.SchemaProps{
				Description: "Maximum allowed grace period (in seconds) to use when terminating pods in response to a soft eviction threshold being met.",
				Type:        []string{"integer"},
				Format:      "int32",
			},
		},
		"evictionMinimumReclaim": {
			SchemaProps: spec.SchemaProps{
				Description: "Comma-delimited list of minimum reclaims (e.g. imagefs.available=2Gi) that describes the minimum amount of resource the kubelet will reclaim when performing a pod eviction if that resource is under pressure.",
				Type:        []string{"string"},
				Format:      "",
			},
		},
		"podsPerCore": {
			SchemaProps: spec.SchemaProps{
				Description: "Maximum number of pods per core. Cannot exceed MaxPods",
				Type:        []string{"integer"},
				Format:      "int32",
			},
		},
		"enableControllerAttachDetach": {
			SchemaProps: spec.SchemaProps{
				Description: "enableControllerAttachDetach enables the Attach/Detach controller to manage attachment/detachment of volumes scheduled to this node, and disables kubelet from executing any attach/detach operations",
				Type:        []string{"boolean"},
				Format:      "",
			},
		},
		"systemReserved": {
			SchemaProps: spec.SchemaProps{
				Description: "A set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for non-kubernetes components. Currently only cpu and memory are supported. [default=none] See http://releases.k8s.io/HEAD/docs/user-guide/compute-resources.md for more detail.",
				Type:        []string{"object"},
				AdditionalProperties: &spec.SchemaOrBool{
					Schema: &spec.Schema{
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
				},
			},
		},
		"kubeReserved": {
			SchemaProps: spec.SchemaProps{
				Description: "A set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for kubernetes system components. Currently only cpu and memory are supported. [default=none] See http://releases.k8s.io/HEAD/docs/user-guide/compute-resources.md for more detail.",
				Type:        []string{"object"},
				AdditionalProperties: &spec.SchemaOrBool{
					Schema: &spec.Schema{
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
				},
			},
		},
		"protectKernelDefaults": {
			SchemaProps: spec.SchemaProps{
				Description: "Default behaviour for kernel tuning",
				Type:        []string{"boolean"},
				Format:      "",
			},
		},
		"makeIPTablesUtilChains": {
			SchemaProps: spec.SchemaProps{
				Description: "If true, Kubelet ensures a set of iptables rules are present on host. These rules will serve as utility rules for various components, e.g. KubeProxy. The rules will be created based on IPTablesMasqueradeBit and IPTablesDropBit.",
				Type:        []string{"boolean"},
				Format:      "",
			},
		},
		"iptablesMasqueradeBit": {
			SchemaProps: spec.SchemaProps{
				Description: "iptablesMasqueradeBit is the bit of the iptables fwmark space to mark for SNAT Values must be within the range [0, 31]. Must be different from other mark bits. Warning: Please match the value of corresponding parameter in kube-proxy",
				Type:        []string{"integer"},
				Format:      "int32",
			},
		},
		"iptablesDropBit": {
			SchemaProps: spec.SchemaProps{
				Description: "iptablesDropBit is the bit of the iptables fwmark space to mark for dropping packets. Values must be within the range [0, 31]. Must be different from other mark bits.",
				Type:        []string{"integer"},
				Format:      "int32",
			},
		},
		"allowedUnsafeSysctls": {
			SchemaProps: spec.SchemaProps{
				Description: "Whitelist of unsafe sysctls or sysctl patterns (ending in *). Use these at your own risk. Resource isolation might be lacking and pod might influence each other on the same node.",
				Type:        []string{"array"},
				Items: &spec.SchemaOrArray{
					Schema: &spec.Schema{
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
				},
			},
		},
	}
	schema.Required = []string{"TypeMeta", "podManifestPath", "syncFrequency", "fileCheckFrequency", "httpCheckFrequency", "manifestURL", "manifestURLHeader", "enableServer", "address", "port", "readOnlyPort", "tlsCertFile", "tlsPrivateKeyFile", "certDirectory", "hostnameOverride", "podInfraContainerImage", "dockerEndpoint", "rootDirectory", "seccompProfileRoot", "allowPrivileged", "hostNetworkSources", "hostPIDSources", "hostIPCSources", "registryPullQPS", "registryBurst", "eventRecordQPS", "eventBurst", "enableDebuggingHandlers", "minimumGCAge", "maxPerPodContainerCount", "maxContainerCount", "cAdvisorPort", "healthzPort", "healthzBindAddress", "oomScoreAdj", "registerNode", "clusterDomain", "masterServiceNamespace", "clusterDNS", "streamingConnectionIdleTimeout", "nodeStatusUpdateFrequency", "imageMinimumGCAge", "imageGCHighThresholdPercent", "imageGCLowThresholdPercent", "lowDiskSpaceThresholdMB", "volumeStatsAggPeriod", "networkPluginName", "networkPluginDir", "networkPluginMTU", "volumePluginDir", "cloudProvider", "cloudConfigFile", "kubeletCgroups", "runtimeCgroups", "systemCgroups", "cgroupRoot", "containerRuntime", "remoteRuntimeEndpoint", "remoteImageEndpoint", "runtimeRequestTimeout", "rktPath", "rktAPIEndpoint", "rktStage1Image", "lockFilePath", "exitOnLockContention", "configureCbr0", "hairpinMode", "babysitDaemons", "maxPods", "nvidiaGPUs", "dockerExecHandlerName", "podCIDR", "resolvConf", "cpuCFSQuota", "containerized", "maxOpenFiles", "reconcileCIDR", "registerSchedulable", "contentType", "kubeAPIQPS", "kubeAPIBurst", "serializeImagePulls", "experimentalFlannelOverlay", "outOfDiskTransitionFrequency", "nodeIP", "nodeLabels", "nonMasqueradeCIDR", "enableCustomMetrics", "evictionHard", "evictionSoft", "evictionSoftGracePeriod", "evictionPressureTransitionPeriod", "evictionMaxPodGracePeriod", "evictionMinimumReclaim", "podsPerCore", "enableControllerAttachDetach", "systemReserved", "kubeReserved", "protectKernelDefaults", "makeIPTablesUtilChains", "iptablesMasqueradeBit", "iptablesDropBit"}
	return openapi.OpenAPIType{
		Schema: &schema,
		Dependencies: map[string]interface{}{
			"unversioned.Duration": unversioned.Duration{},
			"unversioned.TypeMeta": unversioned.TypeMeta{},
		},
	}
}

func (_ LeaderElectionConfiguration) OpenAPI() openapi.OpenAPIType {
	schema := spec.Schema{}
	schema.Description = "LeaderElectionConfiguration defines the configuration of leader election clients for components that can run with leader election enabled."
	schema.Properties = map[string]spec.Schema{
		"leaderElect": {
			SchemaProps: spec.SchemaProps{
				Description: "leaderElect enables a leader election client to gain leadership before executing the main loop. Enable this when running replicated components for high availability.",
				Type:        []string{"boolean"},
				Format:      "",
			},
		},
		"leaseDuration": {
			SchemaProps: spec.SchemaProps{
				Ref: spec.MustCreateRef("#/definitions/unversioned.Duration"),
			},
		},
		"renewDeadline": {
			SchemaProps: spec.SchemaProps{
				Ref: spec.MustCreateRef("#/definitions/unversioned.Duration"),
			},
		},
		"retryPeriod": {
			SchemaProps: spec.SchemaProps{
				Ref: spec.MustCreateRef("#/definitions/unversioned.Duration"),
			},
		},
	}
	schema.Required = []string{"leaderElect", "leaseDuration", "renewDeadline", "retryPeriod"}
	return openapi.OpenAPIType{
		Schema: &schema,
		Dependencies: map[string]interface{}{
			"unversioned.Duration": unversioned.Duration{},
		},
	}
}
