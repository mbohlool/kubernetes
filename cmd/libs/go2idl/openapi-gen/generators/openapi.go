/*
Copyright 2016 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package generators

import (
	"bytes"
	"fmt"
	"io"
	"path/filepath"
	"reflect"
	"strings"

	"k8s.io/kubernetes/cmd/libs/go2idl/args"
	"k8s.io/kubernetes/cmd/libs/go2idl/generator"
	"k8s.io/kubernetes/cmd/libs/go2idl/namer"
	"k8s.io/kubernetes/cmd/libs/go2idl/types"
	"k8s.io/kubernetes/pkg/genericapiserver/openapi"
	"k8s.io/kubernetes/pkg/util/sets"

	"github.com/golang/glog"
	"sort"
)

// This is the comment tag that carries parameters for open API generation.
const tagName = "openapi"

// Known values for the tag.
const (
	tagValueDefinition = "definition"
	tagValuePackage    = "package"
	tagValueExclude    = "ignore"
	// Should only be used only for test
	tagValueShouldFail = "should-fail"
)

func hasOpenAPITagValue(comments []string, value string) bool {
	tagValues := types.ExtractCommentTags("+", comments)[tagName]
	if tagValues == nil {
		return false
	}
	for _, val := range tagValues {
		if val == value {
			return true
		}
	}
	return false
}

// NameSystems returns the name system used by the generators in this package.
func NameSystems() namer.NameSystems {
	return namer.NameSystems{
		"raw": namer.NewRawNamer("", nil),
	}
}

// DefaultNameSystem returns the default name system for ordering the types to be
// processed by the generators in this package.
func DefaultNameSystem() string {
	return "raw"
}

func Packages(context *generator.Context, arguments *args.GeneratorArgs) generator.Packages {
	boilerplate, err := arguments.LoadGoBoilerplate()
	if err != nil {
		glog.Fatalf("Failed loading boilerplate: %v", err)
	}
	inputs := sets.NewString(context.Inputs...)
	packages := generator.Packages{}
	header := append([]byte(fmt.Sprintf("// +build !%s\n\n", arguments.GeneratedBuildTag)), boilerplate...)
	header = append(header, []byte(
		`
// This file was autogenerated by openapi-gen. Do not edit it manually!

`)...)

	for i := range inputs {
		glog.V(5).Infof("considering pkg %q", i)
		pkg := context.Universe[i]
		if pkg == nil {
			// If the input had no Go files, for example.
			continue
		}
		pkgHasTag := hasOpenAPITagValue(pkg.Comments, tagValuePackage)
		NeedsGeneration := pkgHasTag
		if !pkgHasTag {
			// If the pkg-scoped tag did not exist, scan all types for one that
			// explicitly wants generation.
			for _, t := range pkg.Types {
				glog.V(5).Infof("  considering type %q", t.Name.String())
				if hasOpenAPITagValue(t.CommentLines, tagValueDefinition) {
					NeedsGeneration = true
					break
				}
			}
		}

		if NeedsGeneration {
			packages = append(packages,
				&generator.DefaultPackage{
					PackageName: strings.Split(filepath.Base(pkg.Path), ".")[0],
					PackagePath: pkg.Path,
					HeaderText:  header,
					GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
						generators = []generator.Generator{}
						generators = append(
							generators, NewOpenAPIGen(arguments.OutputFileBaseName, pkg.Path, pkgHasTag, context))
						return generators
					},
					FilterFunc: func(c *generator.Context, t *types.Type) bool {
						return t.Name.Package == pkg.Path
					},
				})
		}
	}
	return packages
}

const (
	specPackagePath    = "github.com/go-openapi/spec"
	openAPIPackagePath = "k8s.io/kubernetes/pkg/genericapiserver/openapi"
)

// openApiGen produces a file with auto-generated OpenAPI functions.
type openAPIGen struct {
	generator.DefaultGen
	targetPackage string
	allTypes      bool
	imports       namer.ImportTracker
	context       *generator.Context
}

func NewOpenAPIGen(sanitizedName, targetPackage string, allTypes bool, context *generator.Context) generator.Generator {
	return &openAPIGen{
		DefaultGen: generator.DefaultGen{
			OptionalName: sanitizedName,
		},
		targetPackage: targetPackage,
		allTypes:      allTypes,
		imports:       generator.NewImportTracker(),
		context:       context,
	}
}

func (g *openAPIGen) Namers(c *generator.Context) namer.NameSystems {
	// Have the raw namer for this file track what it imports.
	return namer.NameSystems{
		"raw": namer.NewRawNamer(g.targetPackage, g.imports),
	}
}

func (g *openAPIGen) Filter(c *generator.Context, t *types.Type) bool {
	if hasOpenAPITagValue(t.CommentLines, tagValueExclude) {
		return false
	}
	if hasOpenAPITagValue(t.CommentLines, tagValueDefinition) {
		return true
	}
	// There is a conflict between this codegen and codecgen, we should avoid types generated for codecgen
	if strings.HasPrefix(t.Name.Name, "codecSelfer") {
		return false
	}
	return g.allTypes
}

func (g *openAPIGen) isOtherPackage(pkg string) bool {
	if pkg == g.targetPackage {
		return false
	}
	if strings.HasSuffix(pkg, "\""+g.targetPackage+"\"") {
		return false
	}
	return true
}

func (g *openAPIGen) Imports(c *generator.Context) []string {
	importLines := []string{}
	for _, singleImport := range g.imports.ImportLines() {
		if g.isOtherPackage(singleImport) {
			importLines = append(importLines, singleImport)
		}
	}
	return importLines
}

func argsFromType(t *types.Type) generator.Args {
	return generator.Args{
		"type":           t,
		"OpenAPIType":    types.Ref(openAPIPackagePath, "OpenAPIType"),
		"SpecSchemaType": types.Ref(specPackagePath, "Schema"),
	}
}

func (g *openAPIGen) Init(c *generator.Context, w io.Writer) error {
	return nil
}

func (g *openAPIGen) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {
	if hasOpenAPITagValue(t.CommentLines, tagValueShouldFail) {
		glog.V(5).Infof("Expecting generation to fail for type %v", t)
		buffer := &bytes.Buffer{}
		err := newOpenAPITypeWriter(generator.NewSnippetWriter(buffer, c, "$", "$")).generate(t)
		buffer.Reset()
		if err == nil {
			return fmt.Errorf("Expect OpenAPI generation for type %v to fail but it is not.", t.Name.Name)
		}
		return nil
	}

	glog.V(5).Infof("generating for type %v", t)
	sw := generator.NewSnippetWriter(w, c, "$", "$")
	err := newOpenAPITypeWriter(sw).generate(t)
	if err != nil {
		return err
	}
	return sw.Error()
}

type openAPITypeWriter struct {
	*generator.SnippetWriter
	refTypes map[string]*types.Type
}

func newOpenAPITypeWriter(sw *generator.SnippetWriter) openAPITypeWriter {
	return openAPITypeWriter{
		SnippetWriter: sw,
		refTypes:      map[string]*types.Type{},
	}
}

func fmtRawDoc(CommentLines []string) string {
	var buffer bytes.Buffer
	delPrevChar := func() {
		if buffer.Len() > 0 {
			buffer.Truncate(buffer.Len() - 1) // Delete the last " " or "\n"
		}
	}

	for _, line := range CommentLines {
		// Ignore all lines after ---
		if line == "---" {
			break
		}
		line = strings.TrimRight(line, " ")
		leading := strings.TrimLeft(line, " ")
		switch {
		case len(line) == 0: // Keep paragraphs
			delPrevChar()
			buffer.WriteString("\n\n")
		case strings.HasPrefix(leading, "TODO"): // Ignore one line TODOs
		case strings.HasPrefix(leading, "+"): // Ignore instructions to go2idl
		default:
			if strings.HasPrefix(line, " ") || strings.HasPrefix(line, "\t") {
				delPrevChar()
				line = "\n" + line + "\n" // Replace it with newline. This is useful when we have a line with: "Example:\n\tJSON-someting..."
			} else {
				line += " "
			}
			buffer.WriteString(line)
		}
	}

	postDoc := strings.TrimRight(buffer.String(), "\n")
	postDoc = strings.Replace(postDoc, "\\\"", "\"", -1) // replace user's \" to "
	postDoc = strings.Replace(postDoc, "\"", "\\\"", -1) // Escape "
	postDoc = strings.Replace(postDoc, "\n", "\\n", -1)
	postDoc = strings.Replace(postDoc, "\t", "\\t", -1)
	postDoc = strings.Trim(postDoc, " ")

	return postDoc
}

func getJsonTags(m *types.Member) []string {
	jsonTag := reflect.StructTag(m.Tags).Get("json")
	if jsonTag == "" {
		return []string{}
	}
	return strings.Split(jsonTag, ",")
}

func getReferableName(m *types.Member) string {
	jsonTags := getJsonTags(m)
	if len(jsonTags) > 0 {
		if jsonTags[0] == "-" {
			return ""
		} else {
			return jsonTags[0]
		}
	} else {
		return m.Name
	}
}

func isPropertyRequired(m *types.Member) bool {
	jsonTags := getJsonTags(m)
	// A property is required if it does not have omitempty value in its json tag
	return len(jsonTags) < 2 || jsonTags[1] != "omitempty"
}

func (g openAPITypeWriter) generate(t *types.Type) error {
	// Only generate for struct type and ignore the rest
	switch t.Kind {
	case types.Struct:
		args := argsFromType(t)
		g.Do("func (_ $.type|raw$) OpenAPI() $.OpenAPIType|raw$ {\n", args)
		g.Do("schema := $.SpecSchemaType|raw${}\n", args)
		g.Do("schema.Description = \"$.$\"\n", fmtRawDoc(t.CommentLines))
		g.Do("schema.Properties=map[string]spec.Schema{\n", nil)
		required := []string{}
		for _, m := range t.Members {
			name := getReferableName(&m)
			if name == "" {
				continue
			}
			if isPropertyRequired(&m) {
				required = append(required, name)
			}
			if err := g.generateProperty(&m); err != nil {
				return err
			}
		}
		g.Do("}\n", nil)
		if len(required) > 0 {
			g.Do("schema.Required = []string{\"$.$\"}\n", strings.Join(required, "\",\""))
		}
		g.Do("return $.OpenAPIType|raw${\nSchema: &schema,\nDependencies: map[string]interface{}{\n", args)
		// Map order is undefined, sort them or we may get a different file generated each time.
		keys := []string{}
		for k := range g.refTypes {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			v := g.refTypes[k]
			if t, _ := openapi.GetOpenAPITypeFormat(v.String()); t != "" {
				// This is a known type, we do not need a reference to it
				// Will eliminate special case of time.Time
				continue
			}
			g.Do("\"$.$\": ", k)
			g.Do("$.|raw${},\n", v)
		}
		g.Do("},\n}\n}\n\n", nil)
	}
	return nil
}

func (g openAPITypeWriter) generateProperty(m *types.Member) error {
	name := getReferableName(m)
	if name == "" {
		return nil
	}
	description := fmtRawDoc(m.CommentLines)
	g.Do("\"$.$\": {\n", name)
	g.Do("SchemaProps: spec.SchemaProps{\n", nil)
	jsonTags := getJsonTags(m)
	if len(jsonTags) > 1 && jsonTags[1] == "string" {
		g.generateSimpleProperty("string", "")
		g.Do("},\n},\n", nil)
		return nil
	}
	t := resolvedAliasType(m.Type)
	if t.Kind == types.Pointer {
		t = t.Elem
	}
	t = resolvedAliasType(t)
	// If we can get a openAPI type and format for this type, we consider it to be simple property
	typeString, format := openapi.GetOpenAPITypeFormat(t.String())
	if typeString != "" {
		g.Do("Description: \"$.$\",\n", description)
		g.generateSimpleProperty(typeString, format)
		g.Do("},\n},\n", nil)
		return nil
	}
	switch t.Kind {
	case types.Builtin:
		return fmt.Errorf("Please add type %v to getOpenAPITypeFormat function.", t)
	case types.Map:
		g.Do("Description: \"$.$\",\n", description)
		if err := g.generateMapProperty(t); err != nil {
			return err
		}
	case types.Slice, types.Array:
		g.Do("Description: \"$.$\",\n", description)
		if err := g.generateSliceProperty(t); err != nil {
			return err
		}
	case types.Struct, types.Interface:
		g.generateReferenceProperty(t)
	default:
		return fmt.Errorf("Cannot generate spec for type %v.", t)
	}
	g.Do("},\n},\n", nil)
	return g.Error()
}

func (g openAPITypeWriter) generateSimpleProperty(typeString, format string) {
	g.Do("Type: []string{\"$.$\"},\n", typeString)
	g.Do("Format: \"$.$\",\n", format)
}

func (g openAPITypeWriter) generateReferenceProperty(t *types.Type) {
	var name string
	if t.Name.Package == "" {
		name = t.Name.Name
	} else {
		name = filepath.Base(t.Name.Package) + "." + t.Name.Name
	}
	g.refTypes[name] = t
	g.Do("Ref: spec.MustCreateRef(\"#/definitions/$.$\"),\n", name)
}

func resolvedAliasType(t *types.Type) *types.Type {
	ret := t
	for ret.Kind == types.Alias {
		ret = ret.Underlying
	}
	return ret
}

func (g openAPITypeWriter) generateMapProperty(t *types.Type) error {
	keyType := resolvedAliasType(t.Key)
	elemType := resolvedAliasType(t.Elem)

	// According to OpenAPI examples, only map from string is supported
	if keyType.Name.Name != "string" {
		return fmt.Errorf("Map with non-string keys are not supported by OpenAPI in %v", t)
	}
	g.Do("Type: []string{\"object\"},\n", nil)
	g.Do("AdditionalProperties: &spec.SchemaOrBool{\nSchema: &spec.Schema{\nSchemaProps: spec.SchemaProps{\n", nil)
	switch elemType.Kind {
	case types.Builtin:
		typeString, format := openapi.GetOpenAPITypeFormat(elemType.String())
		g.generateSimpleProperty(typeString, format)
	case types.Struct:
		g.generateReferenceProperty(t.Elem)
	case types.Slice, types.Array:
		g.generateSliceProperty(elemType)
	default:
		return fmt.Errorf("Map Element kind %v is not supported in %v", elemType.Kind, t.Name)
	}
	g.Do("},\n},\n},\n", nil)
	return nil
}

func (g openAPITypeWriter) generateSliceProperty(t *types.Type) error {
	elemType := resolvedAliasType(t.Elem)
	g.Do("Type: []string{\"array\"},\n", nil)
	g.Do("Items: &spec.SchemaOrArray{\nSchema: &spec.Schema{\nSchemaProps: spec.SchemaProps{\n", nil)
	switch elemType.Kind {
	case types.Builtin:
		typeString, format := openapi.GetOpenAPITypeFormat(elemType.String())
		g.generateSimpleProperty(typeString, format)
	case types.Struct:
		g.generateReferenceProperty(t.Elem)
	default:
		return fmt.Errorf("Slice Element kind %v is not supported in %v", elemType.Kind, t)
	}
	g.Do("},\n},\n},\n", nil)
	return nil
}
